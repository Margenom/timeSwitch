;some progs(if (string=? "" out) "" "\n")
(define (string-next str chr) (let rec((i 0)) (if (= i (string-length str)) #f (if (char=? (string-ref str i) chr) i (rec (+ i 1))))))
(define (string-take str to) (substring str 0 to))
(define (string-drop str from) (substring str from (string-length str)))
(define (read-until-line str) (do ((ln (read-line) (read-line)) (out "" (string-append out  ln ))) ((or (eof-object? ln) (and str (string=? ln str))) out)))
;(define (read-file file) (with-input-from-file file (lambda() (read-until-line #f))))
(define (print . toprint) (if (null? toprint) (newline) (begin (display (car toprint)) (display " ") (apply print (cdr toprint)))))
(define (string-next-sub str sub) (let ((exist #f)) 
	(do ((i 0 (+ i 1))) ((or (= (+ i (string-length sub)) (string-length str)) 
		(set! exist (string=? (substring str i (+ i (string-length sub))) sub))) (and exist i)))))
(define (while->list subj next test? sub) (let rec((part subj) (out '())) 
	(if (test? part) (rec (next part) (cons (sub part) (reverse out))) out)))
(define (string-split str sep) (let ((sepind 0))
	(while->list str (lambda(sbj) (string-drop sbj sepind))
		(lambda(sbj) (set! sepind (string-next-sub)))
		(lambda(sbj) (string-take str (string-length sep))))))
(define*(chomp str (skip " \t\n") )
	(define (test i) (member (string-ref str i) (string->list skip)))
	(define (inkv i v) (if (test i) (+ i v) i))
	(let rec ((b 0) (e (-(length str)1)))
		(if (and (test b) (test e)) (rec (inkv b 1) (inkv e -1))
			(substring str b (+ e 1)))))

;(define (eform form . parts) 
;	(let concat((bt (string->list form)) (mode 0) (out '()))
;		(cond ((null? bt) (list->string (reverse out)))
;			((= 0 mode) (let ((mode (char=? (car bt) #\$)))
;				(concat (cdr bt) (if mode 1 0) (if mode out (cons (car bt) out)))))
;			((and (= 1 mode) (char=? (car bt) #\})) (
;			((= 1 mode) 
;				(concat		)))))))

